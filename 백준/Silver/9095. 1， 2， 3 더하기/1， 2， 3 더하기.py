"""
다이나믹 프로그래밍을 활용하여 문제를 해결할 수 있습니다. 
점화식을 세워보면 다음과 같습니다.

n = 1: 1
n = 2: 2
n = 3: 4
n > 3: dp[n] = dp[n-1] + dp[n-2] + dp[n-3]

여기서 dp[n]은 n을 1, 2, 3의 합으로 나타내는 방법의 수를 의미합니다. 
따라서 n이 1, 2, 3일 경우에 대해서는 미리 값을 설정하고, 
그 이상일 경우에는 점화식을 활용하여 값을 계산합니다.
"""

t = int(input()) # 테스트 케이스의 개수

# dp 배열 초기화
dp = [0] * 11
dp[1] = 1
dp[2] = 2
dp[3] = 4

# dp 배열 계산
for i in range(4, 11):
    dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

# 테스트 케이스별로 결과 출력
for _ in range(t):
    n = int(input())
    print(dp[n])

"""
위 코드에서 dp 배열의 크기를 11로 설정한 이유는 문제에서 n이 11보다 작다고 명시되어 있기 때문입니다.
만약 n이 더 큰 수일 경우에는 dp 배열의 크기를 그에 맞게 조정해주면 됩니다.
"""
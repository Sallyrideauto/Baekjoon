"""
그리디 알고리즘은 현재 상황에서 가장 최적의 선택을 하는 알고리즘이기 때문에, 
동전 가치의 크기가 작은 동전부터 선택하여 K원을 만드는데 필요한 
동전 개수의 최솟값을 구할 수 있습니다.
"""

N, K = map(int, input().split())
coins = [int(input()) for _ in range(N)]

count = 0
for i in range(N-1, -1, -1):
    if coins[i] <= K:
        count += K // coins[i]
        K %= coins[i]

print(count)

"""
위 코드는 동전 가치의 크기가 큰 것부터 선택하는 대신, 
동전 가치의 크기가 작은 것부터 선택하도록 반복문을 거꾸로 돌리는 것을 제외하면 이전 코드와 동일합니다. 
따라서 메모리 초과 문제는 발생하지 않을 것입니다.

"""
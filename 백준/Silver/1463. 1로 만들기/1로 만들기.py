"""
일반적으로 다이나믹 프로그래밍은 작은 문제들의 결과를 이용하여 큰 문제를 해결하는 방식으로 구현됩니다.

이 문제에서도 다이나믹 프로그래밍을 이용해 구현할 수 있습니다. 
정수 X를 1로 만들기 위한 최소 연산 횟수를 D[X]라고 하면, 다음과 같은 점화식을 구할 수 있습니다.

D[X] = min(D[X//3], D[X//2], D[X-1]) + 1

여기서 "//" 연산자는 정수 나누기 연산을 의미합니다. 
즉, X를 3으로 나눈 몫, X를 2로 나눈 몫, 그리고 X에서 1을 뺀 값 중에서 최소값을 구하면 됩니다. 
이 점화식은 X를 1로 만들기 위한 최소 연산 횟수를 구하는 문제를 해결할 수 있습니다.
"""

n = int(input())

# D[i]는 i를 1로 만들기 위한 최소 연산 횟수를 저장하는 배열
D = [0] * (n + 1)

for i in range(2, n+1):
    # 1을 뺀 경우
    D[i] = D[i-1] + 1
    
    # 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        D[i] = min(D[i], D[i//2] + 1)
    
    # 3으로 나누어 떨어지는 경우
    if i % 3 == 0:
        D[i] = min(D[i], D[i//3] + 1)

print(D[n])

"""
위 코드에서 D[i]는 i를 1로 만들기 위한 최소 연산 횟수를 저장하는 배열입니다. 
D[1]은 0으로 초기화되어 있으며, 2부터 n까지의 값을 구합니다. 
이 때, 점화식에 따라 D[i]를 계산합니다.

위 코드는 시간 복잡도가 O(n)입니다. 
따라서 입력값이 커지면 연산 시간이 급격히 증가할 수 있습니다. 
이 경우, 다이나믹 프로그래밍의 메모이제이션 기법을 사용하면 연산 시간을 줄일 수 있습니다.
"""